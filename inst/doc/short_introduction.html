<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Short Introduction</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Short Introduction</h1>

<p><code>TLMoments</code> is a set of functions whose main functionality is the calculation of Trimmed L-moments and their parameter and quantile estimates. One of the goals is to reduce computation time compared to existing implementations (in packages like <code>lmomco</code>, <code>Lmoments</code>, <code>Lmom</code>), therefore the core functions are written in C++ (see vignette &ldquo;comparison of computation time&rdquo; for speed comparisons). Furthermore, the package expands the combinations of trimmings that can be used to estimate distribution parameters in comparison to existing packages (which mainly supports parameter estimation with L-moments). To ensure an easy usage, the package only contains a small set of functions. This vignette gives a short introduction to the most important ones and their usage. </p>

<h2>Calculation of empirical TL-moments, parameter and quantile estimates.</h2>

<p>First we have a look at the basic functionality of calculating TL-moments and parameter and quantile estimates. Let assume we have a simple random data vector generated from a GEV distribution:</p>

<pre><code class="r">xvec &lt;- rgev(100, loc = 10, scale = 5, shape = .2)
</code></pre>

<p>TL-moments are calculated by the function <code>TLMoments</code> with arguments <code>leftrim</code>, <code>rightrim</code>, and <code>max.order</code> (generating an object of class <code>TLMoments</code>): </p>

<pre><code class="r">TLMoments(xvec)
</code></pre>

<pre><code>## $lambdas
##         L1         L2         L3         L4 
## 14.0173473  4.0593659  1.3221238  0.9849437 
## 
## $ratios
##        T1        T2        T3        T4 
##        NA 0.2895959 0.3256971 0.2426349
</code></pre>

<pre><code class="r">TLMoments(xvec, leftrim = 0, rightrim = 1, max.order = 2)
</code></pre>

<pre><code>## $lambdas
##       L1       L2 
## 9.957981 2.052932 
## 
## $ratios
##        T1        T2 
##        NA 0.2061594
</code></pre>

<p>We can generate parameters estimates by putting a <code>TLMoments</code>-object to the function <code>parameters</code> and specifying argument <code>distr</code>: </p>

<pre><code class="r">tlm &lt;- TLMoments(xvec)
parameters(tlm, distr = &quot;gev&quot;)
</code></pre>

<pre><code>##        loc      scale      shape 
## 10.1085022  4.5048954  0.2296688
</code></pre>

<pre><code class="r">tlm &lt;- TLMoments(xvec, rightrim = 1)
parameters(tlm, distr = &quot;gev&quot;)
</code></pre>

<pre><code>##        loc      scale      shape 
## 10.1635352  4.5531879  0.1981091
</code></pre>

<p>This generates an object of class <code>parameters</code>, which can be transmitted to <code>quantiles</code> to calculate quantile estimations: </p>

<pre><code class="r">tlm &lt;- TLMoments(xvec)
quantiles(parameters(tlm, distr = &quot;gev&quot;), c(.9, .99, .999))
</code></pre>

<pre><code>##      0.9     0.99    0.999 
## 23.38218 46.91199 86.33208
</code></pre>

<pre><code class="r">tlm &lt;- TLMoments(xvec, rightrim = 1)
quantiles(parameters(tlm, distr = &quot;gev&quot;), c(.9, .99, .999))
</code></pre>

<pre><code>##      0.9     0.99    0.999 
## 23.07477 44.35414 77.48191
</code></pre>

<h2>Support for different data types:</h2>

<p>These three functions, <code>TLMoments</code>, <code>parameters</code>, and <code>quantiles</code>, provide the main functionality of the package. In the code above we used single data vectors only, but the same functions can be used for data matrices, lists, and data.frames as well. To demonstrate this, let&#39;s generate sample data of these four types: </p>

<pre><code class="r">xmat &lt;- matrix(rgev(100), nc = 4)
xvec &lt;- xmat[, 3]
xlist &lt;- lapply(1L:ncol(xmat), function(i) xmat[, i])
xdat &lt;- data.frame(station = rep(1:4, each = 25), hq = as.vector(xmat))
</code></pre>

<p>Note that the type of the dimensions <code>lambdas</code> and <code>ratios</code> returned by <code>TLMoments</code> matches the input type: </p>

<pre><code class="r">TLMoments(xvec, leftrim = 0, rightrim = 1)
</code></pre>

<pre><code>## $lambdas
##           L1           L2           L3           L4 
## -0.118853990  0.345356673  0.001151761  0.056987284 
## 
## $ratios
##           T1           T2           T3           T4 
##           NA -2.905722163  0.003334991  0.165009942
</code></pre>

<pre><code class="r">TLMoments(xmat, leftrim = 0, rightrim = 1)
</code></pre>

<pre><code>## $lambdas
##          [,1]        [,2]         [,3]        [,4]
## L1 0.02344548 -0.23776608 -0.118853990 -0.11898376
## L2 0.30767794  0.42364590  0.345356673  0.45702513
## L3 0.03664748 -0.02546122  0.001151761  0.10543062
## L4 0.06705632  0.08328394  0.056987284  0.08181004
## 
## $ratios
##          [,1]        [,2]         [,3]       [,4]
## T1         NA          NA           NA         NA
## T2 13.1231242 -1.78177604 -2.905722163 -3.8410715
## T3  0.1191099 -0.06010024  0.003334991  0.2306889
## T4  0.2179432  0.19658857  0.165009942  0.1790056
</code></pre>

<pre><code class="r">TLMoments(xlist, leftrim = 0, rightrim = 1)
</code></pre>

<pre><code>## $lambdas
## $lambdas[[1]]
##         L1         L2         L3         L4 
## 0.02344548 0.30767794 0.03664748 0.06705632 
## 
## $lambdas[[2]]
##          L1          L2          L3          L4 
## -0.23776608  0.42364590 -0.02546122  0.08328394 
## 
## $lambdas[[3]]
##           L1           L2           L3           L4 
## -0.118853990  0.345356673  0.001151761  0.056987284 
## 
## $lambdas[[4]]
##          L1          L2          L3          L4 
## -0.11898376  0.45702513  0.10543062  0.08181004 
## 
## 
## $ratios
## $ratios[[1]]
##         T1         T2         T3         T4 
##         NA 13.1231242  0.1191099  0.2179432 
## 
## $ratios[[2]]
##          T1          T2          T3          T4 
##          NA -1.78177604 -0.06010024  0.19658857 
## 
## $ratios[[3]]
##           T1           T2           T3           T4 
##           NA -2.905722163  0.003334991  0.165009942 
## 
## $ratios[[4]]
##         T1         T2         T3         T4 
##         NA -3.8410715  0.2306889  0.1790056
</code></pre>

<pre><code class="r">TLMoments(xdat, hq ~ station, leftrim = 0, rightrim = 1)
</code></pre>

<pre><code>## $lambdas
##   station          L1        L2           L3         L4
## 1       1  0.02344548 0.3076779  0.036647475 0.06705632
## 2       2 -0.23776608 0.4236459 -0.025461222 0.08328394
## 3       3 -0.11885399 0.3453567  0.001151761 0.05698728
## 4       4 -0.11898376 0.4570251  0.105430617 0.08181004
## 
## $ratios
##   station        T2           T3        T4
## 1       1 13.123124  0.119109857 0.2179432
## 2       2 -1.781776 -0.060100243 0.1965886
## 3       3 -2.905722  0.003334991 0.1650099
## 4       4 -3.841072  0.230688882 0.1790056
</code></pre>

<p>This holds when parameter and quantile estimations are calculated: </p>

<pre><code class="r">tlm &lt;- TLMoments(xvec, leftrim = 0, rightrim = 1)
parameters(tlm, &quot;gev&quot;)
</code></pre>

<pre><code>##         loc       scale       shape 
## -0.01397485  0.80481126 -0.04136686
</code></pre>

<pre><code class="r">tlm &lt;- TLMoments(xmat, leftrim = 0, rightrim = 1)
parameters(tlm, &quot;gev&quot;)
</code></pre>

<pre><code>##             [,1]        [,2]        [,3]       [,4]
## loc   0.04889176 -0.05425236 -0.01397485 -0.1670314
## scale 0.67814071  0.99798598  0.80481126  0.9185783
## shape 0.21866118 -0.19640922 -0.04136686  0.4447258
</code></pre>

<pre><code class="r">tlm &lt;- TLMoments(xlist, leftrim = 0, rightrim = 1)
parameters(tlm, &quot;gev&quot;)
</code></pre>

<pre><code>## [[1]]
##        loc      scale      shape 
## 0.04889176 0.67814071 0.21866118 
## 
## [[2]]
##         loc       scale       shape 
## -0.05425236  0.99798598 -0.19640922 
## 
## [[3]]
##         loc       scale       shape 
## -0.01397485  0.80481126 -0.04136686 
## 
## [[4]]
##        loc      scale      shape 
## -0.1670314  0.9185783  0.4447258
</code></pre>

<pre><code class="r">tlm &lt;- TLMoments(xdat, hq ~ station, leftrim = 0, rightrim = 1)
parameters(tlm, &quot;gev&quot;)
</code></pre>

<pre><code>##   station         loc     scale       shape
## 1       1  0.04889176 0.6781407  0.21866118
## 2       2 -0.05425236 0.9979860 -0.19640922
## 3       3 -0.01397485 0.8048113 -0.04136686
## 4       4 -0.16703142 0.9185783  0.44472579
</code></pre>

<pre><code class="r">tlm &lt;- TLMoments(xvec, leftrim = 0, rightrim = 1)
quantiles(parameters(tlm, &quot;gev&quot;), c(.99, .999))
</code></pre>

<pre><code>##    0.99   0.999 
## 3.35734 4.82140
</code></pre>

<pre><code class="r">tlm &lt;- TLMoments(xmat, leftrim = 0, rightrim = 1)
quantiles(parameters(tlm, &quot;gev&quot;), c(.99, .999))
</code></pre>

<pre><code>##            [,1]     [,2]    [,3]     [,4]
## 0.99   5.427518 2.968302 3.35734 13.74486
## 0.999 10.991346 3.718393 4.82140 42.34384
</code></pre>

<pre><code class="r">tlm &lt;- TLMoments(xlist, leftrim = 0, rightrim = 1)
quantiles(parameters(tlm, &quot;gev&quot;), c(.99, .999))
</code></pre>

<pre><code>## [[1]]
##      0.99     0.999 
##  5.427518 10.991346 
## 
## [[2]]
##     0.99    0.999 
## 2.968302 3.718393 
## 
## [[3]]
##    0.99   0.999 
## 3.35734 4.82140 
## 
## [[4]]
##     0.99    0.999 
## 13.74486 42.34384
</code></pre>

<pre><code class="r">tlm &lt;- TLMoments(xdat, hq ~ station, leftrim = 0, rightrim = 1)
quantiles(parameters(tlm, &quot;gev&quot;), c(.99, .999))
</code></pre>

<pre><code>##   station      0.99     0.999
## 1       1  5.427518 10.991346
## 2       2  2.968302  3.718393
## 3       3  3.357340  4.821400
## 4       4 13.744859 42.343836
</code></pre>

<h2>Distributions</h2>

<p><code>TLMoments</code> offers functions (distributions, density, quantile, random number generation) for the generalized extreme value distribution (<code>gev</code>), Gumbel distribution (<code>gum</code>), generalized Pareto distribution (<code>gpd</code>), and three-parameter lognormal distribution (<code>ln3</code>) in the common <code>p|d|q|r</code>-syntax. The parameter (and quantile) estimation functionality works for all of them, but more complex functionality like estimation of the covariance matrix of parameter or quantile estimators only works for GEV by now. </p>

<h2>Calculations using theoretical TL-moments and parameters</h2>

<p>The functions <code>as.TLMoments</code> and <code>as.parameters</code> can be used to construct <code>TLMoments</code>- or <code>parameters</code>-objects of theoretical values (not calculated from data). These objects can be used in the same way like before (to convert between TL-moments and their parameters or to calculate the corresponding quantiles): </p>

<pre><code class="r">(tlm &lt;- as.TLMoments(c(14.1, 4.3, 1.32)))
</code></pre>

<pre><code>## $lambdas
##    L1    L2    L3 
## 14.10  4.30  1.32 
## 
## $ratios
##        T1        T2        T3 
##        NA 0.3049645 0.3069767
</code></pre>

<pre><code class="r">parameters(tlm, distr = &quot;gev&quot;)
</code></pre>

<pre><code>##        loc      scale      shape 
## 10.0134305  4.9448851  0.2034746
</code></pre>

<pre><code class="r">quantiles(parameters(tlm, distr = &quot;gev&quot;), c(.9, .99, .999))
</code></pre>

<pre><code>##      0.9     0.99    0.999 
## 24.12668 47.67693 84.80024
</code></pre>

<pre><code class="r">(param &lt;- as.parameters(loc = 10, scale = 5, shape = .2, distr = &quot;gev&quot;))
</code></pre>

<pre><code>##   loc scale shape 
##  10.0   5.0   0.2
</code></pre>

<pre><code class="r">quantiles(param, c(.9, .99, .999))
</code></pre>

<pre><code>##      0.9     0.99    0.999 
## 24.21069 47.73413 84.51684
</code></pre>

<pre><code class="r">TLMoments(param)
</code></pre>

<pre><code>## $lambdas
##         L1         L2         L3         L4 
## 14.1057429  4.3279754  1.3204343  0.9436158 
## 
## $ratios
##        T1        T2        T3        T4 
##        NA 0.3068236 0.3050928 0.2180271
</code></pre>

<pre><code class="r">TLMoments(param, rightrim = 1)
</code></pre>

<pre><code>## $lambdas
##        L1        L2        L3        L4 
## 9.7777681 2.2556564 0.2512127 0.2553529 
## 
## $ratios
##        T1        T2        T3        T4 
##        NA 0.2306924 0.1113701 0.1132056
</code></pre>

<p>Note, that we can simply use the <code>TLMoments</code>-function to calculate TL-moments corresponding to a <code>parameters</code>-object. </p>

<h2>Summary functions</h2>

<p>Objects of type <code>TLMoments</code>, <code>parameters</code>, or <code>quantiles</code> (i.e. results from the functions of the same name) feature <code>summary</code>-functions, which give confidence intervals and an overview of the data. </p>

<pre><code class="r">tlm &lt;- TLMoments(rgev(100), leftrim = 0, rightrim = 1)

summary(tlm)
</code></pre>

<pre><code>## 1 data row(s) with n = 100.
## TL(0,1) calculated. 
## 
## Approximate 0.9% confidence interval of TL moments: 
##             LCL   lambda_hat        UCL
## L1 -0.120675775  0.033253218 0.18718221
## L2  0.353034660  0.397368875 0.44170309
## L3 -0.031864235 -0.004586798 0.02269064
## L4  0.005323102  0.024067309 0.04281152
## Approximate 0.9% confidence interval of TL moment ratios: 
##             LCL     tau_hat         UCL
## T2 -43.08154521 11.94978699 66.98111919
## T3  -0.08012055 -0.01154292  0.05703471
## T4   0.01167740  0.06056667  0.10945594
</code></pre>

<pre><code class="r">summary(tlm, ci.level = .95, select = 3:4)
</code></pre>

<pre><code>## 1 data row(s) with n = 100.
## TL(0,1) calculated. 
## 
## Approximate 0.95% confidence interval of TL moments: 
##             LCL   lambda_hat        UCL
## L3 -0.037089869 -0.004586798 0.02791627
## L4  0.001732209  0.024067309 0.04640241
## Approximate 0.95% confidence interval of TL moment ratios: 
##             LCL    tau_hat       UCL
## T3 -0.021148618 0.06056667 0.1422820
## T4  0.002311506 0.06056667 0.1188218
</code></pre>

<pre><code class="r">summary(parameters(tlm, &quot;gev&quot;))
</code></pre>

<pre><code>## 1 data row(s) with n = 100.
## TL(0,1) used to generate GEV parameters. 
## 
## Approximate 0.9% confidence interval of parameters: 
##               LCL      param        UCL
## loc   -0.01082746  0.1658265 0.34248044
## scale  0.80458149  0.9296128 1.05464414
## shape -0.23910542 -0.0768813 0.08534282
</code></pre>

<pre><code class="r">summary(quantiles(parameters(tlm, &quot;gev&quot;), .99))
</code></pre>

<pre><code>## 1 data row(s) with n = 100.
## TL(0,1) used to generate GEV parameters to calculate 0.99 quantile estimates. 
## 
## Approximate 0.9% confidence interval of quantiles: 
##           LCL quantile      UCL
## 0.99 2.564796 3.767776 4.970755
</code></pre>

<p>At the moment, the summary functions does not work for data in lists or data.frames. </p>

<h2>Magrittr syntax</h2>

<p><code>TLMoments</code> is built to support the use in <code>magrittr</code> syntax. The nesting of functions can be written more readable as: </p>

<pre><code class="r">library(magrittr)

TLMoments(xvec, leftrim = 0, rightrim = 1) %&gt;% 
  parameters(&quot;gev&quot;) %&gt;% 
  quantiles(c(.99, .999))
</code></pre>

<pre><code>##    0.99   0.999 
## 3.35734 4.82140
</code></pre>

</body>

</html>
